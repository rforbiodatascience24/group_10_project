---
title: "02_clean_v2"
format: html
editor: visual
---

## Loading Libraries

Loading libraries which will be used for the data wrangling

```{r}
rm(list=ls())
library("tidyverse")
library("purrr")
library("broom")
library("readr")
library("here")
```

## Loading Data

Loading the tsv file from the data folder.

```{r}
data <- read_tsv(here("data/01_data_load.tsv"))
```

## Inspect Data

Inspecting the data to get the number of observations and variables in the raw data.

```{r}
# View the first few observations and variables

# Print the dimensions of the dataframe
data |>
  dim_desc()
```

The three rules for making a data set tidy must be satisfied. Each variable must have its own column, each observation have its own row, and each value have its own cell.

It can be observed, from viewing the data, that multiple of the variables contain more than one value. Therefore, each value does not have its own cell which means the data is not tidy.

To make sure the data is tidy these values are separated into different columns/variables.

## Data Wrangling

The variable "Uses" contains the many different ways the drug is being used by the specific patient.

```{r}
data |>
  select(Uses) |>
  head()
```

It can be observed that one observation can contain multiple different ways the drug is utilized. Therefore this variable is split into different columns of applications, in order for each column to only contain one type of usage.

```{r}
#Removing "Treatment of", "Prevention of", "Treatment and prevention of" in each row and anything in parenthensis to isolate types of usage.

clean_data <- data |>
  mutate(Uses = str_replace_all(Uses,
                                "(?<!\\s)Treatment of",
                                "")) |> 
  mutate(Uses = str_replace_all(Uses,
                                "(?<!\\s)Prevention of",
                                "")) |> 
  mutate(Uses = str_replace_all(Uses,
                                "(?<!\\s)Treatment and prevention of",
                                "")) |> 
  
  # Removing information in parenthensis.
  mutate(Uses = str_replace_all(Uses,
                                "\\(.*?\\)", 
                                ""))

# Printing only unique, partially cleaned "Uses" data
clean_data |> 
  select(Uses) |>
  distinct() |>
  print()
```

As can be seen from the "Uses" of only unique observations, the data is not yet tidy. We would like to separate the usage types based on splitting at every encounter with capital letters. However, examples of abbreviations such as "HIV" is present in the data set and does not result in correct splitting. Therefore, the data is cleaned further by removing periods, backslash, and hyphens, as they do not convey any more information.

```{r}
clean_data <- clean_data |> 
  
  #Period, backslash, and hyphen are removed.
  mutate(Uses = str_replace_all(Uses,
                                "[./-]",
                                "")) |> 
  
  #"HIV" is converted to only have the first letter as a capital letter.
  mutate(Uses = str_replace_all(Uses,
                                "HIV",
                                "Hiv")) |> 
  
  #Every word consisting of only capital letters are converted to lower case e.g. "Vitamin B" becomes "Vitamin b"
  mutate(Uses = str_replace_all(Uses, 
                                "\\b[A-Z]+\\b", 
                                ~str_to_lower(.)))
```

The data is now ready to be split into applications.

```{r}


clean_data <- clean_data |>
  separate(
    Uses,
    into = str_c("Application_",seq(1,10)), #Creating application colomns
    sep = "(?=[A-Z])", # Splits if the word starts with capital letter
    extra = "merge", # Additional content is merged into the last column 
    fill = "right" # Fills empty columns with NA
  )

clean_data |> 
  select("Medicine Name", 
         Application_1:Application_10)
```

To ensure the right amount of application variables are made in the code above, we check if there is anything in the specific column other than NAs.

```{r}

#### Tror det her kunne blive mere pipet :)

clean_data |>
  summarize(non_na_count = sum(!is.na(`Application_9`))) |> # Counts non-NA in column Application_9 
  pull(non_na_count) # Extract calculated count


clean_data |>
  summarize(non_na_count = sum(!is.na(`Application_10`))) |> # Counts non-NA columns
  pull(non_na_count) # Extract calculated count
```

It isn't until application number 10 that there are only NAs. Therefore 9 application columns are sufficient.

It is interesting to investigate how many unique usages there are for the drugs. This is done in the code below where all application variables are put into one variable called "Observations". All duplicate observations are removed by using the "distinct" command, and all NAs are excluded using "filter".

(this code should probably be moved to augment og describe doc)

```{r}
observations_count <- clean_data |>
  select(str_c("Application_",
               seq(1,10))) |>
  pivot_longer(cols = everything(), 
               values_to = "Observations") |> 
  filter(!is.na(Observations)) |> 
  print()
```

Here we see that there are a total of 30,364 observations if the observations are not collected into unique types of usage. This is done in the following code by the use of distinct:

```{r}
unique_observations <- observations_count |> 
  distinct(Observations) |> 
  filter(!is.na(Observations))

print(unique_observations)
  
```

There are a total of 628 unique usages for the drugs.\

Furthermore, the variable "Medicine Name" also contains multiple values in each cell. It carries information about both the name of the drug, the amount of drug administrated, and the administration route. This information should be split into separate columns.

```{r}
data |>
  select('Medicine Name') |>
  slice()

```

Because there are different routes of administration the units for the dose are also different. For instance tablets are given in mg, a cream or a gel in percentages, Syrups in ml, a Penfill is given in IU (biological activity) etc.

Information about the dose is also available in the variable "Composition", and in this variable it is more detailed. In the "Medicine Name" variable it isn't always explained which unit, the number is given in. Because information about the dose can be found in both variables, but the unit is unsure in "Medicine Name", information about the dose is just removed and discarded from this variable.

```{r}
clean_data <- clean_data |>

  mutate(API = str_split(Composition, pattern = "\\+")) |>

  unnest_wider(API, names_sep = "_")


```

```{r}
clean_data <- clean_data |> 
  mutate(
    # Extract drug name (everything before the first number)
    across(starts_with("API"), ~ str_extract(.x, "^[a-zA-Z\\s]+"), .names = "name_{.col}"),
    across(starts_with("API"), ~ as.numeric(str_extract(.x, "\\d+\\.?\\d*")), .names = "amount_{.col}"),
    across(starts_with("API"), 
           ~ str_sub(.x, 
                     start = str_locate(.x, "\\(")[, 1] + str_length(str_extract(.x, "\\d+\\.?\\d*")) + 1, 
                     end = str_locate(.x, "\\)")[, 1] - 1), 
           .names = "unit_{.col}"))




```

```{r}
clean_data <- clean_data |>
  mutate(

    `Medicine Name` = str_extract(`Medicine Name`,
                                  "^[^0-9]+"))
clean_data <- clean_data |>
  mutate(
    `Administration_route` = str_extract(`Medicine Name`, "\\w+$")  
    )

```

### Splitting side effects into columns for each, by captial letter

All the side effects from the various medicines are collected in a single variable called 'Side_effects.' These are split into separate variables by dividing the text at capital letters

```{r}
clean_data <- clean_data |>
  
  # Split the string on capital letters, skipping the first character
  mutate(SE = map(Side_effects, ~ {
    #defining first character and saving for adding later
    first_char <- substr(.x, 1, 1)
    
    # defining rest which we now can split on
    rest <- substring(.x, 2)
    
    # splitting on substring with removed first captial letter to avoid empty first         column
    split_rest <- str_split(rest, pattern = "(?=[A-Z])")[[1]]
    
    # and adding the first character back for the first SE column for each row 
    c(paste0(first_char, split_rest[1]), split_rest[-1])
  }))  |>
  
  # Unnest the list column into multiple columns
  unnest_wider(SE, names_sep = "_")

```

```{r}
#removing columns we don't need anymore

clean_data1 <- clean_data %>%
  select(-Composition, -`Side_effects`, -starts_with("API_"))
```

\#############################################################

FROM HERE I HAVE MADE nothing.

Note:

\^(\[\^ \]+): Captures the first word up to space,

(.\*)\$: Captures the rest of the string up to space

Got stuck on this.\
Tried to split by the first number occuring below instead:

```{r}
# clean_data2 <- data |>
#   extract(
#     `Medicine Name`, 
#     into = c("Medicine Name", "Rest"),
#     regex = "^([^0-9]+)(.*)$",  # Splits at the first number
#     remove = FALSE
#   )
```

The "Composition" variable contains information about both the different drugs the overall medication is made of, and the amount of each different drug. This should also be put into different variables.

Firstly this variable is split into a column per different drug type, by separating by the +'s. Secondly each of these new variables are split into a "Drug name" and a "Drug dose" column.

```{r}
# clean_data3 <- data |>
#   separate(
#     `Composition`, 
#     into = c("Drug name 1", "Drug name 2", "Drug name 3", "Drug name 4", "Drug name 5", "Drug name 6", "Drug name 7", "Drug name 8", "Drug name 9"), 
#     sep = " \\+ ",       # Split at " + " (space plus space)
#     fill = "right",      # Ensures rows without a "+" will have NA in "Drug name 2"
#     extra = "merge"      # In case there are multiple "+" signs, keep the rest in "Drug name 2"
#   )
```

Again, checking when there is a column with only NAs, so there shouldn't be made any more Drug name variables:

```{r}
# clean_data3 |>
#   summarize(non_na_count = sum(!is.na(`Drug name 9`))) |> # Counts non-NA columns
#   pull(non_na_count) # Extract calculated count
```

At the 10th type of drug there is no non-NA values.

Then for splitting name of the specific drug and amount of drug, we see that there is always brackets around the drug amount, therefore we can split by the first "(".

(blev ikke helt færdig med det her, de har nogle mærkelige navne)

```{r}
# clean_data4 <- clean_data3 |>
#   pivot_longer(
#     cols = starts_with("Drug name"),         
#     names_to = "Drug Column",               
#     values_to = "Drug Info"                 
#   ) |>
#   separate(
#     `Drug Info`, 
#     into = c("Drug Name", "Drug dose"),  
#     sep = " \\(",  
#     extra = "merge", 
#     fill = "right"                        
#   ) |>
#   pivot_wider(
#     names_from = `Drug Column`,         
#     values_from = c("Drug Name", "Drug dose")
#   )

```

.
